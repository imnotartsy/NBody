# -*- coding: utf-8 -*-
"""PHY68 - Project II.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14cnQYVF80YDeo2YbNhtdgxC-LRwIVspH

# Phy 68: P2
Project II
Gustavo, Charlotte Moore, Teo Patrosio

## Architecture for N-Body Problem
"""

# Imports
import matplotlib.pyplot as plt
import numpy as np
from collections import namedtuple
from collections import defaultdict

Body = namedtuple("Body", "m x y z vx vy vz ax ay az")



################################################################################
# ! Configuration
# TODO: Add your potential and force function here!
################################################################################
def componentGravF(m1, m2, x1, x2, epsilon):
  G = 6.67e-11
  if abs(x2 - x1) <= epsilon:
    f = 0
  elif (x2 - x1) > 0:
    f =  G * (m1 * m2)/(x2 - x1)**2
  elif (x2 - x1) < 0:
    f = - G * (m1 * m2)/(x2 - x1)**2

  return f


def componentGravP(m1, m2, x1, x2, epsilon):
  G = 6.67e-11
  if abs(x2 - x1) <= epsilon:
    f = 0
  elif (x2 - x1) > 0:
    f =  G * (m1 * m2)/(x2 - x1)
  elif (x2 - x1) < 0:
    f = - G * (m1 * m2)/(x2 - x1)

  return f




################################################################################
#
# * Simulation Helper Functions
#
################################################################################



# Calculate force, returns an array of forces between 
def calculate_force(body, n_bodies, times, i, f, epsilon):
  """ Calculates the force between a body and all other bodies at a given time"""
  forces = []
  for otherbody in n_bodies:
    b1 = times[body]
    b2 = times[otherbody]
    m1 = b1["m"]
    m2 = b2["m"]

    fx = f(m1, m2, b1["x"][i], b2["x"][i], epsilon)
    fy = f(m1, m2, b1["y"][i], b2["y"][i], epsilon)
    fz = f(m1, m2, b1["z"][i], b2["z"][i], epsilon)

    forces.append((fx, fy, fz))
  return forces


# Average force vectors, returns an averaged vector
def averaged_force(forces):
  """ Returns the average force vector """
  fx = 0
  fy = 0
  fz = 0

  for force in forces:
    fx += force[0]
    fy += force[1]
    fz += force[2]

  return (fx/len(forces), fy/len(forces), fz/len(forces))


def calculate_energy(body, n_bodies, times, i, p, epsilon):
  """ Calculates the potential energy of a body at a given time """
  for otherbody in n_bodies:
    b1 = times[body]
    b2 = times[otherbody]
    m1 = b1["m"]
    m2 = b2["m"]

    Ux = p(m1, m2, b1["x"][i], b2["x"][i], epsilon)
    Uy = p(m1, m2, b1["y"][i], b2["y"][i], epsilon)
    Uz = p(m1, m2, b1["z"][i], b2["z"][i], epsilon)

  return -1 *  (Ux** 2 + Uy**2 + Uz**2)**(1/2)
  


################################################################################
#
# * Printing and Plotting Helper Functions
#
################################################################################


# * For a given time, print all of the attributes of the n_bodies
def printBodyAttrs(times, n_bodies, i):
  """ Prints the attributes of each body at a given time"""

  for b in n_bodies:
    print("\t", b, end=": ")
    for attr in times[b]:
      if attr != "m":
        print(attr, times[b][attr][i], end="\t")
      else:
        print(attr, times[b][attr], end="\t")
    print()

# Helper Functions
def plotBodies(n_bodies):
  """ Returns a 2D plot of the x and y position of each body """
  x = [n_bodies[body].x for body in n_bodies]
  y = [n_bodies[body].y for body in n_bodies]
  m = [n_bodies[body].m for body in n_bodies]

  plt.scatter(x, y)
  plt.show()



# 3D graphy: X, Y vs time
def plot_3d(n_bodies, times):
  """ Returns a 3D plot of the x and y position of each body over time """
  fig = plt.figure()
  ax = fig.add_subplot(projection='3d')
  for body in n_bodies:
    ax.scatter(times['times'], times[body]["x"], times[body]["y"])
  ax.set_title('X, Y vs time')
  ax.set_xlabel ('time (sec)')
  ax.set_ylabel('X pos (m)')
  ax.set_zlabel('Y pos (m)')
  plt.show()


# X Position vs Time
def plot_x(n_bodies, times):
  """ Returns a plot of the x position of each body over time"""
  for body in n_bodies:
    plt.scatter(times['times'], times[body]["x"])

  plt.title("X Position vs Time")
  plt.xlabel('Time (sec)')
  plt.ylabel('X Position (m)')
  plt.show()

  plt.figure(figsize=(20,12), dpi=75)
  for body in n_bodies:
    plt.scatter(times['times'], times[body]["fx"])

  plt.title("Force vs Time")
  plt.xlabel('Time (sec)')
  plt.ylabel('Force (N)')
  plt.show()


def plot_energy(n_bodies, times):
  """ Returns a plot of the potential and kinetic energy of each body over time """

  for body in n_bodies:
    plot = plt.scatter(times['times'], times[body]["U"])
    plot.set_label(body + " Potential Energy")
    plot = plt.scatter(times['times'], times[body]["K"])
    plot.set_label(body + " Kinetic Energy")

  plt.title('Energies over Time')
  plt.xlabel('Time')
  plt.ylabel('Energy')
  plt.legend()
  plt.show()

  plt.scatter(times['times'], times["a"]["U"]) #[x/G for x in times["a"]["U"]])
  plt.title('Potential Energy over Time')
  plt.xlabel('Time (sec)')
  plt.ylabel('Energy (J)')
  plt.show()


  plt.scatter(times['times'], times["a"]["K"])
  plt.title('Kinetic Energy over Time')
  plt.xlabel('Time (sec)')
  plt.ylabel('Energy (J)')
  plt.show()


  plt.scatter(times['times'], times["a"]["U"] + times["a"]["K"])
  plt.title('Total Energy over Time')
  plt.xlabel('Time (sec)')
  plt.ylabel('Energy (J)')
  plt.show()





################################################################################
#
# * Discretization
#
################################################################################


def iterate(tf, res, n_bodies_init, p, f, epsilon=.05, debug=False):
  """ Returns a "times" dictionary with the following structure:
    times = {
        "times" : [t0, t+res, t+res*2, ... tf],
        "a" : {
            "m" : 1,
            "x" : [x0, x1, x2, ...],  
            "y" : [y0, y1, y2, ...],  
            "z" : [z0, z1, z2, ...],  
            "vx": [vx0, vx1, vx2, ...],
            "vy": [vy0, vy1, vy2, ...],
            "vz": [vz0, vz1, vz2, ...],
            "ax": [ax0, ax1, ax2, ...],
            "ay": [ay0, ay1, ay2, ...],
            "az": [az0, az1, az2, ...],
            "U" : [U0, U1, U2, ...],
            "K" : [K0, K1, K2, ...],
            "fx": [fx0, fx1, fx2, ...],
            "fy": [fy0, fy1, fy2, ...],
            "fz": [fz0, fz1, fz2, ...],
        },
        ...
    }

  """
  # * Initialize variables for time simulation
  tf += res - (tf % res)
  nsteps = int(tf/res)
  dt = (tf)/nsteps
  t = [i* res for i in range(nsteps)]

  n_bodies = list(n_bodies_init.keys())


  # * Create data structure for holding time data
  times = defaultdict(dict)
  for b in n_bodies:
    times[b] = {
        "m" : 0,
        "x" : np.zeros([nsteps]), 
        "y" : np.zeros([nsteps]),
        "z" : np.zeros([nsteps]),
        "vx": np.zeros([nsteps]),
        "vy": np.zeros([nsteps]),
        "vz": np.zeros([nsteps]),
        "ax": np.zeros([nsteps]),
        "ay": np.zeros([nsteps]),
        "az": np.zeros([nsteps]),
        "fx": np.zeros([nsteps]),
        "fy": np.zeros([nsteps]),
        "fz": np.zeros([nsteps]),

        "U": np.zeros([nsteps]),
        "K": np.zeros([nsteps])
    }

  times['times'] = t


  # * Set initial conditions for simulation
  for b in n_bodies:
    times[b]['m']     = n_bodies_init[b].m
    times[b]['x'][0]  = n_bodies_init[b].x
    times[b]['y'][0]  = n_bodies_init[b].y
    times[b]['z'][0]  = n_bodies_init[b].z
    times[b]['vx'][0] = n_bodies_init[b].vx
    times[b]['vy'][0] = n_bodies_init[b].vy
    times[b]['vz'][0] = n_bodies_init[b].vz
    times[b]['ax'][0] = n_bodies_init[b].ax
    times[b]['ay'][0] = n_bodies_init[b].ay
    times[b]['az'][0] = n_bodies_init[b].az
    

  # * Simulate time
  for i in range(0, nsteps-1):
    print("time:", t[i])
    if debug:
      printBodyAttrs(times, n_bodies, i)


    # * Calculate and apply forces for each body
    for body in n_bodies:
      forces = calculate_force(body, n_bodies, times, i, componentGravF, epsilon)

      # * Average the forces
      force = averaged_force(forces)
      if debug:
        print("\t", body, "forces:", force)#[round(f, 4) for f in force])


      # * Set next position

      # * Incrememnt accelerations: a = f/m
      times[body]["fx"][i+1] = force[0]
      times[body]["fy"][i+1] = force[1]
      times[body]["fz"][i+1] = force[2]

      times[body]["ax"][i+1] = force[0]/times[body]["m"]
      times[body]["ay"][i+1] = force[1]/times[body]["m"]
      times[body]["az"][i+1] = force[2]/times[body]["m"]

      # * Incrememnt velocities: v_f = v_i + a * t
      times[body]["vx"][i+1] = times[body]["vx"][i] + times[body]["ax"][i+1] * dt
      times[body]["vy"][i+1] = times[body]["vy"][i] + times[body]["ay"][i+1] * dt
      times[body]["vz"][i+1] = times[body]["vz"][i] + times[body]["az"][i+1] * dt
      

      # * Incrememnt positions
      # Bashforth adams
      if BA==True:
        times[body]["x"][i+1] = times[body]["x"][i] + ((3/2) * times[body]["vx"][i] - (1/2)*times[body]["vx"][i-1]) * dt
        times[body]["y"][i+1] = times[body]["y"][i] + ((3/2) * times[body]["vy"][i] - (1/2)*times[body]["vy"][i-1]) * dt
        times[body]["z"][i+1] = times[body]["z"][i] + ((3/2) * times[body]["vz"][i] - (1/2)*times[body]["vz"][i-1]) * dt

      # Euler
      else:
        times[body]["x"][i+1] = times[body]["x"][i] + times[body]["vx"][i+1] * dt
        times[body]["y"][i+1] = times[body]["y"][i] + times[body]["vy"][i+1] * dt
        times[body]["z"][i+1] = times[body]["z"][i] + times[body]["vz"][i+1] * dt


      # Energy
      times[body]["U"][i+1] = calculate_energy(body, n_bodies, times, i, componentGravP, epsilon)
      times[body]["K"][i+1] = 1/2 * times[body]["m"]*(times[body]["vx"][i+1]**2 + times[body]["vy"][i+1]**2 + times[body]["vz"][i+1]**2)

  return times




